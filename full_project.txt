----------------------------------------
SOURCE FILE: include/ICipher.hpp
----------------------------------------
#pragma once

#include <string>

class ICipher{
	public:
	virtual std::string encrypt(const std::string& data, const std::string& key) const = 0;
	virtual std::string decrypt(const std::string& encrypted_data, const std::string& key) const = 0;

	virtual ~ICipher() = default;
};



----------------------------------------
SOURCE FILE: include/PasswordEntry.hpp
----------------------------------------
#pragma once

#include <string>
#include "ICipher.hpp"
#include <XorCipher.hpp>

class PasswordEntry{
private:
	std::string service_name;
	std::string login;
	std::string password;

public:
    PasswordEntry(
        const std::string& service_name, 
        const std::string& login, 
        const std::string& password, 
        const std::string& master_key, 
        const ICipher& cipher
    );

    PasswordEntry(
        const std::string& service_name, 
        const std::string& login, 
        const std::string& encrypted_password
    );

	void display() const;

	std::string getDecryptedPassword(
        const ICipher& cipher, 
        const std::string& master_key
        ) const;

    std::string getService() const {return service_name;}
    std::string getLogin() const {return login;}
    std::string getEncryptedPassword() const {return password;}
};



----------------------------------------
SOURCE FILE: include/Vault.hpp
----------------------------------------
#pragma once
#include "ICipher.hpp"
#include "PasswordEntry.hpp"
#include <string>
#include <vector>
#include <memory>

class Vault{
private:
    std::unique_ptr<ICipher> cipher;
    std::vector<PasswordEntry> entries;

public:
    Vault(std::unique_ptr<ICipher> cipher);

    void addEntry(
        const std::string& source,
        const std::string& login,
        const std::string& password,
        const std::string& master_key
    );

    const PasswordEntry* findEntry(const std::string& service) const;

    void saveToFile(const std::string& filename) const;
    void loadFromFile(const std::string& filename);
    
};



----------------------------------------
SOURCE FILE: include/XorCipher.hpp
----------------------------------------
#pragma once

#include "ICipher.hpp"

class XorCipher : public ICipher{
	public:
	std::string encrypt(const std::string& data, const std::string& key) const override;
	std::string decrypt(const std::string& encrypted_data, const std::string& key) const override; 
    std::string toHex(const std::string& input);
    std::string fromHex(const std::string& input);
};



----------------------------------------
SOURCE FILE: source/PasswordEntry.cpp
----------------------------------------
#include "PasswordEntry.hpp"
#include <XorCipher.hpp>
#include <stdexcept>
#include <iostream>

PasswordEntry::PasswordEntry(
    const std::string& service_name, 
    const std::string& login, 
    const std::string& password, 
    const std::string& master_key, 
    const ICipher& cipher
){
    if(service_name.empty())
        throw std::invalid_argument("Service name is empty");
    if(login.empty())
        throw std::invalid_argument("Login is empty");
    if(password.empty())
        throw std::invalid_argument("Password is empty");
    
    this->service_name = service_name;
    this->login = login;
    this->password = cipher.encrypt(password, master_key); 
}

PasswordEntry::PasswordEntry(
    const std::string &service_name, 
    const std::string &login, 
    const std::string &encrypted_password
) {
    if(service_name.empty())
        throw std::invalid_argument("Service name is empty");
    if(login.empty())
        throw std::invalid_argument("Login is empty");
    if(encrypted_password.empty())
        throw std::invalid_argument("Encrypted password is empty");
    
    this->service_name = service_name;
    this->login = login;
    this->password = encrypted_password;
}

void PasswordEntry::display() const{
	std::cout << "Service: "  << service_name << std::endl;
	std::cout << "Login: "    << login        << std::endl;
	std::cout << "Password: " << "********"   << std::endl;    
	std::cout << std::endl;
}

std::string PasswordEntry::getDecryptedPassword(
        const ICipher& cipher, 
        const std::string& master_key
) const{
	std::string result = cipher.decrypt(password, master_key);
	return result;
}





----------------------------------------
SOURCE FILE: source/Vault.cpp
----------------------------------------
#include "Vault.hpp"
#include <string>
#include <memory>
#include <algorithm>
#include <fstream>

Vault::Vault(std::unique_ptr<ICipher> cipher){
    if (cipher == nullptr) 
        throw std::invalid_argument("Cipher can't be nullptr");

    this->cipher = std::move(cipher);
}


void Vault::addEntry(
    const std::string& source,
    const std::string& login,
    const std::string& password,
    const std::string& master_key
) {
    entries.emplace_back(source, login, password, master_key, *this->cipher);
}


const PasswordEntry* Vault::findEntry(const std::string& service) const {
    auto it = std::find_if(entries.begin(), entries.end(),
    [&service](const PasswordEntry& e){
        return e.getService() == service;
    });

    if(it != entries.end()){
        return &(*it);
    }

    return nullptr;
}

void Vault::saveToFile(const std::string& filename) const{
    std::ofstream file(filename);
    if (!file.is_open()) 
        throw std::runtime_error("Could not open file for writing");

    //mini costil must be changed when new cipher be added
    auto xor_ptr = dynamic_cast<XorCipher*>(cipher.get());

    for(const auto& entry : entries){
        std::string safe_pass = xor_ptr ? 
            xor_ptr->toHex(entry.getEncryptedPassword()) : 
            entry.getEncryptedPassword();

        file << entry.getService() << "|" 
             << entry.getLogin() << "|" 
             << safe_pass << "\n"; 
    }

    file.close();
}

void Vault::loadFromFile(const std::string& filename) {
    std::ifstream file(filename);

    if (!file.is_open()) 
        return; // If the file doesn't exist, we simply return without throwing an error
    
    std::string line;
    while (std::getline(file, line)) {
        size_t pos1 = line.find('|');
        size_t pos2 = line.find('|', pos1 + 1);

        if(pos1 == std::string::npos || pos2 == std::string::npos) 
            continue; // Skip malformed lines

        std::string service = line.substr(0, pos1);
        std::string login = line.substr(pos1 + 1, pos2 - pos1 - 1);
        std::string encrypted_password = line.substr(pos2 + 1);
        entries.emplace_back(service, login, encrypted_password);
    }
}




----------------------------------------
SOURCE FILE: source/XorCipher.cpp
----------------------------------------
#include "XorCipher.hpp"
#include <stdexcept>
#include <sstream>
#include <iomanip>

std::string XorCipher::encrypt(
    const std::string& data, 
    const std::string& key
) const{
    if (key.empty()) 
        throw std::invalid_argument("Key cannot be empty");
    
    std::string result(data.size(), ' ');
    for(size_t i = 0; i < data.size(); i++){
        result[i] = data[i] ^ key[i % key.size()];
    }		
    return result;
}

std::string XorCipher::decrypt(
    const std::string& encrypted_data, 
    const std::string& key
) const{
    if (key.empty()) 
        throw std::invalid_argument("Key cannot be empty");
    
    std::string result(encrypted_data.size(), ' ');
    for(size_t i = 0; i < encrypted_data.size(); i++){
        result[i] = encrypted_data[i] ^ key[i % key.size()];
    }		
    return result;
}	

std::string XorCipher::toHex(const std::string& input){
    std::ostringstream oss;
    for(auto c : input){
        oss <<  std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(c);  
    }

    return oss.str();
}


std::string XorCipher::fromHex(const std::string& input){
    std::string output;
    for(size_t i = 0; i < input.size(); i += 2){
        std::string byte_string = input.substr(i, 2);
        char byte = static_cast<char>(strtol(byte_string.c_str(), nullptr, 16));
        output.push_back(byte);
    }
    return output;
}



----------------------------------------
SOURCE FILE: source/main.cpp
----------------------------------------
#include <memory>
#include <iostream>
#include <string>
#include "XorCipher.hpp"
#include "Vault.hpp"

std::string master = "top-secret-key";

void saveTest() {
    auto cipher = std::make_unique<XorCipher>();
    Vault vault(std::move(cipher));

    vault.addEntry("Github", "alex_dev", "p@ss123", master);
    vault.addEntry("Google", "alex.work", "work_only_55", master);
    vault.addEntry("Facebook", "alex.fb", "fb_pass_2024", master);

    vault.saveToFile("data.db");
}

void loadTest() {
    auto cipher = std::make_unique<XorCipher>();
    Vault vault(std::move(cipher));

    vault.loadFromFile("data.db");

    std::string query = "Google";
    const PasswordEntry* found = vault.findEntry(query);

    if (found) {
        std::cout << "Found entry for: " << query << std::endl;
        found->display(); // Покажет звездочки

        XorCipher x; 
        std::cout << "Decrypted password: " 
                  << found->getDecryptedPassword(x, master) << std::endl;
    } else {
        std::cout << "Service " << query << " not found." << std::endl;
    }
}

int main() {
    char c; std::cin >> c;
    if(c == 's') {
        saveTest();
    } else if(c == 'l') {
        loadTest();
    } else {
        std::cout << "Invalid option. Use 's' for save test or 'l' for load test." << std::endl;
    }
    
    
    return 0;
}



